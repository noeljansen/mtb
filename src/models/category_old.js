const mongoose = require('mongoose')

/*
 Will need to see how effective the parents property is. Might need to research this more
*/

const categorySchema = new mongoose.Schema({
    name: {
        type: String,
        maxlength: 50,
        required: true,
        trim: true
    },
    parent: {
        type: mongoose.Schema.Types.ObjectId,
        required: false,
        default: undefined,
        ref: 'Category'
    },
    path: {
        /*
       Ancestory path of the category e.g. [grandparent, parent, this] using names e.g. [road, parts, wheels]
           - This will be autogenerated when the category is added based on the parent ID
           - This will be used for the URL, so needs to be unique - How to enforce this?
       */
        type: [String],
        unique: true,
        required: true,
        validate(value) {
            //Validate Category Depth - This will be hardcoded to 3 i.e Grandparent -> Parent -> Child
            if (value.length > 3) throw new Error('Category has to many parents! Categories may only be 3 levels deep!')
        }
    },
    url: {  //This will be the path formatted as URL Relative to /c. This could potentially be a virtual property
        type: String,
        required: false
    },
    children:
        /* 
        This will either be null or an array similar to [[child1,[]], [child2,[]],[child3, [grandchild1]], [child4, [grandchild1, grandchild2]]]
        [0]: child0, []
        [1]: child1, []
        [2]: child2, [grandchild0, grandchild1]
        */
        [{ type: mongoose.Schema.Types.ObjectId, ref: 'Category' }]
}, {
    timestamps: true
})

// #### Category Methods ####

/*
    Find Children Categories. Does not have to be an immediate child. This is needed when deleting or updating a category
    Still need to test this!!
    */
categorySchema.methods.getChildren = async function () {
    //
}

// #### Category Static Methods ### //

/* 
Update the Children arrays of each parent everytime there is a CRUD operation
- Need to change this to accept optional paramater of (newParent) - this will mean it is an update and not an add. For this we will first need to find the old parent and delete, then add to new!
- This is needed when displaying sub-categories
- We already have the parent and grandparent of the category
C - Simply Add
R - Read - Nothing to do
U - Update: Find and modify
D - Delete: Find and delete
*/
categorySchema.methods.updateParentChildren = async function () {
    console.log('In update Parent Children')
    const category = this
    const id = category._id
    const level = category.path.length

    switch (level) {
        case 1: // the category has no parent, so there is nothing to update
            console.log('Case 1')
            break
        case 2: // the category only has one parent
            console.log('Case 2')
            try {
                const parent = await Category.findById(category.parent)
                var found = false
                //First see if the this is in the parent, i.e. an update and not an add
                parent.children.forEach((child, i) => {
                    if (child[0] == id) { //remember that children is a two dimensional array
                        // This already exists, need to update ID
                        parent.children[i][0] = id
                        found = true
                    }
                })
                if (!found) {
                    //This does not exist in parent yet
                    parent.children.push([category._id, ''])
                }
                await parent.save()
            } catch (e) {
                console.log(e)
                throw new Error('Could not add / update child to parent')
            }
            break
        case 3: //the category has a parent, as well as grandparent
            //First add the child to the parent - This is the same as above - maybe turn into a function?
            console.log('Case 3')
            const parent = await Category.findById(category.parent)
            try {

                var found = false
                //First see if the this is in the parent, i.e. an update and not an add
                parent.children.forEach((child, i) => {
                    console.log(`child[0] : ${child[0]}`)
                    console.log(`id: ${id}`)
                    if (child[0] == id) { //remember that children is a two dimensional array                        
                        // This already exists, need to update ID
                        parent.children[i][0] = id
                        found = true
                    }
                })
                if (!found) {
                    //This does not exist in parent yet
                    parent.children.push([category._id])
                }
                await parent.save()
            } catch (e) {
                console.log(e)
                throw new Error('Could not add / update child to parent')
            }
            //Next, the parent should already be a child in the grandparent
            try {
                const grandParent = await Category.findById(parent.parent)
                console.log(`grandParent: ${grandParent}`)
                grandParent.children.forEach(child => {
                    console.log(`child[0] : ${child[0]}`)
                    console.log(`id: ${id}`)
                    if (child[0] == parent._id) {
                        //If the child already has a grandchildren array, then the category needs to be added to it
                        if (child.length > 1) {
                            child[1].push(category._id)
                        }
                        //Else the grandchildren array must be created and populated with the first grandchild
                        else {
                            child.push([category._id])
                        }
                    }
                })
                await grandParent.save()
            } catch (e) {
                console.log(e)
                throw new Error('Could not update parent in Grandparents children array')

            }
    }
}

const Category = mongoose.model('Category', categorySchema)
module.exports = Category
