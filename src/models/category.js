const mongoose = require('mongoose')

/*
 Will need to see how effective the parents property is. Might need to research this more
*/

const categorySchema = new mongoose.Schema({
    name: {
        type: String,
        maxlength: 50,
        required: true,
        trim: true
    },
    parent: {
        type: mongoose.Schema.Types.ObjectId,
        required: false,
        default: undefined,
        ref: 'Category'
    },
    path: {
        /*
       Ancestory path of the category e.g. [grandparent, parent, this] 
           - This will be autogenerated when the category is added based on the parent ID
           - This will be used for the URL, so needs to be unique - How to enforce this?
       */
        type: [String],
        unique: true,
        required: true,
        validate(value) {
            //Validate Category Depth - This will be hardcoded to 3 i.e Grandparent -> Parent -> Child
            if (value.length > 3) throw new Error('Category has to many parents! Categories may only be 3 levels deep!')
        }
    },
    url: {  //This will be the path formatted as URL Relative to /c. This could potentially be a virtual property
        type: String,
        required: false
    },
    children:
        /* 
        This will either be null or an array similar to [[child1,[]], [child2,[]],[child3, [grandchild1]], [child4, [grandchild1, grandchild2]]]
        */
        [{ type: mongoose.Schema.Types.ObjectId, ref: 'Category' }]
}, {
    timestamps: true
})

// #### Category Methods ####

/*
    Find Children Categories. Does not have to be an immediate child. This is needed when deleting or updating a category
    Still need to test this!!
    */
categorySchema.methods.getChildren = async function () {
    //
}

// #### Category Static Methods ### //

/* 
Update the Children arrays of each parent everytime there is a CRUD operation
- This is needed when displaying sub-categories
- We already have the parent and grandparent of the category
*/
categorySchema.methods.updateChildren = async function () {
    const category = this
    const level = category.path.length

    switch (level) {
        case 1: // the category has no parent, so there is nothing to update
            console.log('Case 1')
            break
        case 2: // the category only has one parent
            console.log('Case 2')
            try {
                const parent = await Category.findById(category.parent)
                parent.children.push([category._id])
                await parent.save()
            } catch (e) {
                throw new Error('Could not add child to parent')
            }
            break
        case 3: //the category has a parent, as well as grandparent
            //First add the child to the parent
            console.log('Case 3')
            try {
                const parent = await Category.findById(category.parent)
                parent.children.push([category._id])
                await parent.save()
            } catch (e) {
                throw new Error('Could not add child to parent')
            }
            //Next, the parent should already be a child in the grandparent
            try {
                const grandParent = await Category.findById(parent.parent)
                grantParent.children.forEach(child => {
                    if (child[0] == parent._id) {
                        //If the child already has a grandchildren array, then the category needs to be added to it
                        if (child.length > 1) {
                            child[1].push(category._id)
                        }
                        //Else the grandchildren array must be created and populated with the first grandchild
                        else {
                            child.push([category._id])
                        }
                        break
                    }
                })
                await grandParent.save()
            } catch (e) {
                throw new Error('Could not update parent in Grandparents children array')
            }


            break
    }


}



const Category = mongoose.model('Category', categorySchema)
module.exports = Category
